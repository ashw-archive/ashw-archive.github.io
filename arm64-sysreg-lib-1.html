<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>arm64-sysreg-lib: system registers in C made easy!</title>
  <style>
  img {
    width: 500px;
    height: auto;
  }
  </style>
</head>
<body>
  <p><a href="index.htm">Index</a></p>
  <table><tr><th>Source:</th><td>https://ashw.io/blog/arm64-sysreg-lib/1</td></tr></table>
  <hr />
<h2>Introduction</h2><p>Hi there, in this post I’ll be introducing
 a new project I’ve been working on in my spare time over the last few 
weeks: Arm64 System Register Library (abbrev. arm64-sysreg-lib), a
 new header-only C library for reading/writing 64-bit Arm system 
registers. This first post introduces the library itself, 
including how to download it and begin using it in your own 
projects, then future posts will dive into the technical details of 
how the library actually works “under the hood”.</p><p>Key features of the library include:</p><ul data-rte-list="default"><li><p>Bit structs defined for 263 system registers</p></li><li><p><code>S</code>afe values defined for all writeable registers, with all currently/previously <code>RES1</code> bits set to <code>1</code> and all currently/previously <code>RES0</code> bits cleared to <code>0</code></p></li><li><p>Accessors
 for read, unsafe write, safe write, and read-modify-write sequences 
defined according to register accessibility</p></li><li><p>All 
library calls optimise down to an average of between one and four 
A64 assembly instructions and are inlined with no branches and no 
static storage</p></li><li><p>Support for both <code>gcc</code> and <code>clang</code>, each with <code>-Wall -Wextra -pedantic -Werror</code> flags and supporting both <code>-std=c99</code> and <code>-std=c11</code></p></li><li><p>Automatically generated by parsing the AArch64 System Register XML provided with <a target="_blank" rel="noopener" href="https://developer.arm.com/architectures/cpu-architecture/a-profile/exploration-tools">Arm’s A-Profile CPU Architecture Exploration Tools</a></p></li><li><p><a target="_blank" rel="noopener" href="https://github.com/ashwio/arm64-sysreg-lib">Open source project hosted on GitHub with permissive MIT license</a></p></li></ul><h2>High-level functionality</h2><p>All system registers define a <code>union</code> of the form <code>union &lt;reg&gt;</code> which defines a  <code>._</code> member for raw access to the underlying register value and an anonymous <code>struct</code> for manipulation of the register’s constituent bit fields.</p><p>Example:</p><pre class="pre"><span class="pre_padding">union sctlr_el1
{
    u64 _;
    struct
    {
        u64 m : 1;
        u64 a : 1;
        u64 c : 1;
        u64 sa : 1;
        ...
    };
};</span></pre><p>All writeable registers define a safe value of the form <code>&lt;reg&gt;_SAFEVAL</code> that has all currently or previously&nbsp;<code>RES1</code>&nbsp;fields set to&nbsp;<code>1</code>&nbsp;and all currently or previously&nbsp;<code>RES0</code>&nbsp;fields cleared to&nbsp;<code>0</code>.</p><p>Example:</p><pre class="pre"><span class="pre_padding">static const union sctlr_el3 SCTLR_EL3_SAFEVAL =
{
    .res1_5_4 = 3,
    .eos = 1,
    .res1_16 = 1,
    .res1_18 = 1,
    .eis = 1,
    .res1_23 = 1,
    .res1_29_28 = 3,
};</span></pre><p>Some of these fields are currently&nbsp;<code>RES1</code>&nbsp;bits, such as&nbsp;<code>.res1_5_4</code>&nbsp;for bits [5:4] and&nbsp;<code>.res1_16</code>&nbsp;for bit [16]; setting these to&nbsp;<code>1</code>&nbsp;in
 the safe value ensures portability when running on future CPU 
implementations where those bits have been repurposed into new 
fields, as in these cases a value of&nbsp;<code>1</code>&nbsp;will give the old behaviour while a value of <code>0</code>
 will give the new behaviour, and we don’t want to inadvertently 
enable the new behaviour on those future implementations by 
clearing these bits.</p><p>This is why the&nbsp;<code>.eos</code>&nbsp;and&nbsp;<code>.eis</code>&nbsp;fields are also set to&nbsp;<code>1</code>; these fields were previosuly&nbsp;<code>RES1</code>&nbsp;bits
 but were repurposed into new fields in later revisions of the 
architecture. The user can choose to clear these to&nbsp;<code>0</code>&nbsp;explicitly if they want the new behaviour, but the library defaults to setting them to&nbsp;<code>1</code>&nbsp;in the safe value and, by extension, the&nbsp;<code>safe_write_&lt;reg&gt;()</code>&nbsp;convenience macros discussed later.</p><p>All readable system registers define a read accessor of the form <code>static inline union &lt;reg&gt; read_&lt;reg&gt;( void )</code>, which reads the current value of the system register into its corresponding <code>union</code>.</p><p>Example:</p><pre class="pre"><span class="pre_padding">/* C code */
#include "sysreg/mpidr_el1.h"
u64 foo( void )
{
    return read_mpidr_el1().aff0;
}

/* Compiler output */
mrs     x8, mpidr_el1
and     x0, x8, #0xff
ret</span></pre><p>All writeable system registers define a write accessor of the form <code>static inline void unsafe_write_&lt;reg&gt;( union &lt;reg&gt; val )</code>, which directly writes <code>val</code> into the system register. These functions are prefixed&nbsp;<code>unsafe_</code>&nbsp;to emphasise the fact that they have no provision for helping to ensure that any currently or previously&nbsp;<code>RES1</code>&nbsp;fields are set to&nbsp;<code>1</code>;
 when using these functions it is the responsibility of the 
programmer to ensure that any such bits are set appropriately so 
as to ensure both correct behaviour and future portability. For 
this reason, it is recommended that you instead use <code>safe_write_&lt;reg&gt;()</code>&nbsp;wherever possible, or use the register’s safe value as a basis for constructing the value passed to <code>unsafe_write_&lt;reg&gt;()</code>.</p><p>Example of unsafely writing constituent fields:</p><pre class="pre"><span class="pre_padding">/* C code */
#include "sysreg/sctlr_el1.h"
void foo( void )
{
    union sctlr_el1 val = { .m=1, .c=1, .i=1 };
    unsafe_write_sctlr_el1(val);
}

/* Compiler output */
mov     w8, #0x1005         // Danger! No RES1 bits set! See safe_write_&lt;reg&gt;()
msr     sctlr_el1, x8
ret</span></pre><p>Example of unsafely writing the register’s raw value:</p><pre class="pre"><span class="pre_padding">/* C code */
#include "sysreg/sctlr_el1.h"
void foo( u64 raw )
{
    union sctlr_el1 val =   ;
    unsafe_write_sctlr_el1(val);
}

/* Compiler output */
msr     sctlr_el1, x0
ret</span></pre><h2>Variadic convenience macros</h2><p>Writeable system registers define a convenience macro of the form <code>safe_write_&lt;reg&gt;( … )</code>, and system registers that are both readable and writeable define a convenience macro of the form <code>read_modify_write_&lt;reg&gt;( … )</code>.
 These convenience macros are one of the main highlights of the 
library and allow for powerful manipulation of 64-bit system 
registers while still optimising down to only a handful of A64 
assembly instructions with no branches and no static storage.</p><p>As mentioned earlier, the <code>unsafe_write_&lt;reg&gt;()</code> function does not account for currently or previously <code>RES1</code>
 bits, which may lead to portability issues if the programmer does 
not correctly set these bits based on their desired behaviour. The <code>safe_write_&lt;reg&gt;()</code>
 convenience macro solves this by allowing you to set a variadic 
list of fields, with any unspecified fields defaulting to their 
current/previous <code>RES</code> value i.e. all currently or previously <code>RES1</code> fields not specified in the variadic list will be set to <code>1</code>.</p><p>Example:</p><pre class="pre"><span class="pre_padding">/* C code */
#include "sysreg/sctlr_el1.h"
void foo( void )
{
    safe_write_sctlr_el1( .m=1, .c=1, .i=1 );
}

/* compiler output */
mov     w8, #0x1985
movk    w8, #0x30d0, lsl #16
msr     sctlr_el1, x8
ret</span></pre><p>Note how while we only specified&nbsp;<code>.m=1</code>,&nbsp;<code>.c=1</code>, and&nbsp;<code>.i=1</code>, the value written to&nbsp;<code>SCTLR_EL1</code>&nbsp;also has all currently or previously&nbsp;<code>RES1</code>&nbsp;fields set to&nbsp;<code>1</code>, such as&nbsp;<code>.itd=1</code>,&nbsp;<code>.sed=1</code>,&nbsp;<code>.eos=1</code>, etc.</p><p>Repeating the same, but this time explicitly clearing one of those currently or previously&nbsp;<code>RES1</code>&nbsp;fields to&nbsp;<code>0</code>&nbsp;in the variadic list:</p><pre class="pre"><span class="pre_padding">/* in C */
#include "sysreg/sctlr_el1.h"
void foo( void )
{
    safe_write_sctlr_el1( .m=1, .c=1, .i=1, .itd=0 );
}

/* compiler output */
mov     w8, #0x1905
movk    w8, #0x30d0, lsl #16
msr     sctlr_el1, x8
ret</span></pre><p>Here we can see bit [7] corresponding to&nbsp;<code>.itd</code>&nbsp;in the first&nbsp;<code>MOV</code>&nbsp;has been cleared; the value moved into&nbsp;<code>w8</code>&nbsp;is now&nbsp;<code>0x1905</code>&nbsp;vs&nbsp;<code>0x1985</code>&nbsp;in the earlier example.</p><p>The <code>read_modify_write_&lt;reg&gt;()</code>
 convenience macro works in a similar way, but instead reads the 
current value of a system register, overwrites a variadic list of 
fields, then writes the result back to the system register, the key 
thing here being that any fields not specified in the variadic list 
are untouched.</p><p>Example:</p><pre class="pre"><span class="pre_padding">/* in C */
void foo( void )
{
    read_modify_write_sctlr_el1( .m=1, .c=1, .i=1 );
}

/* compiler output */
mrs     x8, sctlr_el1
mov     w9, #0x1005
orr     x8, x8, x9
msr     sctlr_el1, x8
ret</span></pre><p>Repeating this but clearing a previously <code>RES1</code> field such as <code>.itd=0</code>:</p><pre class="pre"><span class="pre_padding">/* in C */
void foo( void )
{
    read_modify_write_sctlr_el1( .m=1, .c=1, .i=1, .itd=0 );
}

/* compiler output */
mrs     x8, sctlr_el1
and     x8, x8, #0xffffffffffffff7f
mov     w9, #0x1005
orr     x8, x8, x9
msr     sctlr_el1, x8
ret</span></pre><p>Note how the <code>.itd</code> field is cleared using an <code>AND</code> instruction before the other specified fields are <code>ORR</code>’d in. I’ll dive into the technical details of how the variadic macro is able to do that in a future blog post.</p><h2>Building and testing the library</h2><p>Note
 that when you clone the library from GitHub, it will already have 
been built for you using the June 2020&nbsp;(SysReg_xml_v86A-2020-06) 
release of the AArch64 System Register XML. You can simply 
add&nbsp;<code>-I/path/to/arm64-sysreg-lib/include</code>&nbsp;to your compiler flags to begin using the library in your own projects straight away. You can also run the&nbsp;<code><a target="_blank" rel="noopener" href="http://run-tests.py/">run-tests.py</a></code>&nbsp;script to build the compilation tests using your chosen compiler.</p><p>Alternatively, follow the instructions below to build the library yourself.</p><p>The prerequisites to build the library are:</p><ul data-rte-list="default"><li><p>Python 3.8+</p></li><li><p>Beautiful Soup 4 (<code>pip3.8 install beautifulsoup4</code>)</p></li></ul><p>First, download and extract the AArch64 System Register XML from the&nbsp;<a target="_blank" rel="noopener" href="https://developer.arm.com/architectures/cpu-architecture/a-profile/exploration-tools">Arm A-Profile CPU architecture exploration tools page</a>. You can do this manually, or instead use <code>curl</code>:</p><pre class="pre"><span class="pre_padding">$ curl -O <a target="_blank" rel="noopener" href="https://developer.arm.com/-/media/developer/products/architecture/armv8-a-architecture/2020-06/SysReg_xml_v86A-2020-06.tar.gz">https://developer.arm.com/-/media/developer/products/architecture/armv8-a-architecture/2020-06/SysReg_xml_v86A-2020-06.tar.gz</a>
$ tar xf SysReg_xml_v86A-2020-06.tar.gz</span></pre><p>Then run the provided&nbsp;<code><a target="_blank" rel="noopener" href="http://run-build.py/">run-build.py</a></code>&nbsp;script, pointing it at the extracted XML:</p><pre class="pre"><span class="pre_padding">$ python3.8 <a target="_blank" rel="noopener" href="http://run-build.py/">run-build.py</a> /path/to/SysReg_xml_v86A-2020-06</span></pre><p>To test building the generated C headers with your chosen compiler, run the <code>./run-tests.py</code> script:</p><pre class="pre"><span class="pre_padding">$ python3.8 <a target="_blank" rel="noopener" href="http://run-tests.py/">run-tests.py</a> [--keep] COMPILER_PATH [COMPILER_FLAGS]</span></pre><p>For example:</p><pre class="pre"><span class="pre_padding">$ python3.8 <a target="_blank" rel="noopener" href="http://run-tests.py/">run-tests.py</a> /path/to/aarch64-none-elf-gcc </span></pre><p>It is assumed the compiler uses the same flags/switches as&nbsp;<code>gcc</code>&nbsp;and&nbsp;<code>clang</code>, and the script always invokes the compiler with the following flags:</p><pre class="pre"><span class="pre_padding">-Wall -Wextra -pedantic -Werror</span></pre><p>You may pass additional flags to the&nbsp;<code><a target="_blank" rel="noopener" href="http://run-tests.py/">run-tests.py</a></code>&nbsp;script which will be passed in turn to the compiler, for example:</p><pre class="pre"><span class="pre_padding">$ python3.8 <a target="_blank" rel="noopener" href="http://run-tests.py/">run-tests.py</a> /path/to/aarch64-none-elf-gcc -std=c99 -O3</span></pre><p>If no&nbsp;<code>-std</code>&nbsp;flag is provided, the script defaults to&nbsp;<code>-std=c11</code>.</p><p>If no&nbsp;<code>-O</code>&nbsp;flag is provided, the script defaults to&nbsp;<code>-O2</code>.</p><p>If the compiler path contains substring&nbsp;<code>clang</code>&nbsp;and no&nbsp;<code>--target</code>&nbsp;flag is provided, the script defaults to&nbsp;<code>--target=aarch64-none-elf</code>.</p><p>By default the script will cleanup the generated&nbsp;<code>.o</code>&nbsp;object files after finishing the test run; pass the&nbsp;<code>--keep</code>&nbsp;flag before the compiler path if you wish to keep these files.</p><h2>Known issues and limitations</h2><p>At
 time of writing this library is still in development and is not 
yet able to parse all files included in the AArch64 System Register 
XML.</p><p>Of the 485&nbsp;<code>AArch64-*</code>&nbsp;files included in the&nbsp;<code>SysReg_xml_v86A-2020-06</code>&nbsp;release that actually describe system register encodings:</p><ul data-rte-list="default"><li><p>126 are skipped as they correspond to instructions that use the system register encoding space (<code>ic</code>,&nbsp;<code>dc</code>,&nbsp;<code>tlbi</code>,&nbsp;<code>at</code>,&nbsp;<code>cfp</code>,&nbsp;<code>cpp</code>, and&nbsp;<code>dvp</code>)</p></li><li><p>263 successfully build</p></li><li><p>96 fail to parse</p></li></ul><p>Of the 96 that fail to parse:</p><ul data-rte-list="default"><li><p>43 fail as their fields vary, such a when a bit in another register is set to&nbsp;<code>1</code></p></li><li><p>19 fail due to being an arrayed register (<code>&lt;n&gt;</code>)</p></li><li><p>23 fail due to having arrayed fields (<code>&lt;m&gt;</code>,&nbsp;<code>&lt;n&gt;</code>, or&nbsp;<code>&lt;x&gt;</code>)</p></li><li><p>11 fail due to having variable length fields</p></li></ul><p>Support for these registers will be added in future releases.</p><p>Not counted above are external system registers such as&nbsp;<code>GICD_*</code>&nbsp;and&nbsp;<code>GICR_*</code>, support for which will also be added later.</p><h2>Closing words</h2><p>That’s all for now — hope you found it interesting! Please feel free to <a target="_blank" rel="noopener" href="https://github.com/ashwio/arm64-sysreg-lib">download the library from GitHub</a>
 and experiment with using it in your own projects. Any feedback on
 usability and requests for future functionality would be greatly
 appreciated! Let me know if you find it useful. Also, keep an eye 
out for future blog posts in this series where I’ll dive into the 
technical details of how the library is generated and how 
features like the variadic convenience macros actually work.</p>
</body>
</html>
